# Локальный голосовой ввод
###### Речь в текст | STT | ASR | Speech to text

Эта утилита может в режиме реального времени локально распознавать речь с микрофона и вводить её в текстовое поле.

- Работает локально
- Распознаёт поток с микрофона на лету (паралелльно вводу), а не после записи
- Сразу вводит распознанный текст в поле

https://github.com/nikmedoed/speech_to_input/assets/23284564/ad203043-38f4-4af1-976e-70242c57b0e8

## Основной концепт
- Пишем звук с микрофона в буфер в отдельном потоке
- В основном потоке ждём заполнения буфера, подаём модели на распознавание
- Распознавание ведём кусочками, добавляем для затравки последние N (к примеру, 1000) символовов (с обрезкой по словам)
- После распознавания кусочка смотрим какие слова пересеклись (уже выведены)
- Определяем кандидатов для нового вывода, обрезаем последнее слово / сегмент, т.к. оно могло быть записано частично
- Запоминаем позицию последнего выведенного слова
- Отправляем кадидатов для вывода
- Добавляем в буфер ещё часть аудио, объединяем с частью, которую орезали от кандидатов на вывод, распознаём
- Повторяем, в конце распознаём и выводим всё что осталось

## Установка и настройка
- Скачать
- Установить зависимости `pip install -r requirements.txt`
- Открыть `main.py` и указать ваши параметры
	- language = 'ru' - целевой язык спискера
	- vad = False - исползование фильтра удаления молчания (требует тонкой подстройки, иначе удаляет знаки препинания)
	- size = 'large-v3' - доступная модель (также может потроваться изменить процессор в файле ASRProcessor.py, сейчас GPU)
	- SAMPLE_RATE = 16000 - частота дискретизации (16к - дефолт для whisper)
	- selected_device = 1 - виртуальный номер микрофона (0 - устойство по умолчанию, но может не работать)
Пока что все настройки надо делать в коде

## Использование
- Запустить `python main.py`
- Выбрать текстовое поле
- Нажать комбинацию hotkey `ctrl+alt+R` для запуска
- Говорить в выбранный микровон
- Нажать комбинацию hotkey `ctrl+alt+R` для остановки
- Дождаться, когда пропадёт индикатор записи, что означает завершение ввода текста

## Модели и производительность
Используется `faster-whisper` как лучшее по доступности и качеству решение на апрель 2024.
Mobile RTX 4070 на large-3 распознаёт на лету.
Альтернативные решение были не лучше, или требовали ёмкой настройки. Потенциально интересным решением является использование TensorRT (требует реализации backend через docker контейнер) или Whisper JAX (аналогично).

## Разработка
- `streaming_demo_bench.py` - скрипт для проверки возможности ASRProcessor (обёртки модели) распознавать на лету. Полезно для доработки логики распознавания.
- `ASRP_debug_demo.py` - фиктивная версия ASRProcessor, симулирующая работу и обеспечивающая диагнористический вывод для разработки интерфейса.

## ToDo
- [ ] Настройка распознавания
	- [ ] Язык
	- [ ] Модель
	- [ ] Размер модели
	- [ ] Микрофон
	- [ ] Вводить ли в поле или только копировать в буффер
	- [ ] Дораспознавать последнюю часть или останавливаться моментально
	- [ ] Биндинг своих горячих клавиш
- [ ] Графический интерфейс для смены настроек
- [ ] Работа в фонке
	- [ ] Иконка в трее
	- [ ] Автозапуск
	- [ ] Настройка автозапуска
- [ ] Улучшить архитекутуру текущего распознавателя, улучшить код, оптимизировать
- [ ] Распознать на запущенной модели аудио с диска
- [ ] Распознать аудио с потока воспроизведения (что слышу)
- [ ] Распознавать "конференцию" что слышу и говорю
- [ ] Деактивация при молчании

### Идеи улучшения ASR:
- Распознавать некоторую часть уже выведенного кусочка для лучшей связности, сличать 2 варианта нахлёста, корректировать вывод
- Добавить корректор смысла / связности поверх и исправлять уже выведенный текст

## Заметки о проблемах
### Ввод текста
```python
keyboard_control = pynput.keyboard.Controller()
keyboard_control.type(text)
```
- Заменяет '.' и ',' на 'ю' и 'б' при русской раскладке, нужно добавлять свои обработки таких символов.

```python
pyperclip.copy(text)
ctrl = pynput.keyboard.Key.ctrl
keyboard_control.press(ctrl)
keyboard.send(47, do_press=True, do_release=True)
keyboard_control.release(ctrl)
```
- Вставка работает не везде, а лишнее нажатие ctrl нередко вызывает ошибки. Работет очень нестабильно.
- При инициализации опирается на раскладку, и если была русская, то 'v' становится 'м', т.е. вместо вставки получишь вызов crtl+м и ничего. Либо обрабатывать все варианты раскладок, либо слать кодами.
```python
while keyboard.is_pressed('shift') or keyboard.is_pressed('ctrl') or keyboard.is_pressed('alt'):
    time.sleep(0.1)
```
- ввод в поле при попытке остановить через hotkey вызывает проблемы, съедает пробелы, а то делает и похуже, т.к. нажимает горячие клавиши
- Даже с таким кодом иногда пробелы съедаются. Пока не ясно с чем связано, но уже реже. В буффер попадает норм текст, значит проблема на вводе, который мог начаться на долю секунды раньше хоткея остановки

*Также надо помнить, что нажатие горячей клавиши для остановки вызывает конфликт с вводом с клавиатуры*

### Удаление галлюцинаций
Включение VAD нередко убирает знаки пунктуации. Нужно экспериментировать с окном отслеживания тишины. Я подметил, что глюки часто одни и те же, т.е. их можно удалять регуляркой.
```python
self.asr_stop_phrases_regex = r'\s*(' + '|'.join(map(re.escape, asr.STOP_PHRASES)) + r')\s*\.*'
def remove_stop_phrases(self, text):
    return re.sub(self.asr_stop_phrases_regex, '', text, flags=re.IGNORECASE)
```
Это практически не замедляет работу.
Не стоит убирать выражения из буффера распознавания, потому что это вызовет проблемы с поиском дубликатов на выводе. БЫла идея убирать стоп фразы в функции to_flush, которая отвечает за формирование вывода накопившегося буффера, но иногда на вывод может попасть часть фразы, а оставшаяся часть может быть захвачение при выполнение finish. Решил сделать отдельный метод для применения регулярки и применять его прямо перед выводом.
Пока наблюдаю за поведением.
- Кажется, иногда проскакивают стоп фразы
- Не уверен, что не появляется двойных пробелов после удаления

### Остановка, сон, перезапуск
- Была проблема, что поток микровофна останавливался после сна. Решил созданием отдельного класса для управления потоком с логикой перезапуска.
- До сих пор не получилось сделать, чтобы нормально работал ctrl+C для остановки.